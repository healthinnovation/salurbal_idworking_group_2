---
title: "ID Working Group – SALURBAL Climate"
author:
  - name: "Edson Ascencio"
  - name: "Yomali Ferreyra"
  - name: "Gabriel Carrasco"
date: "January 20, 2026"
project:
  type: website
  output-dir: _site
website:
  title: "ID Working Group – SALURBAL Climate"
  navbar: false
format:
  html:
    toc: true
    toc-depth: 4
    number-sections: true
    embed-resources: false
editor: visual
---

```{r}
#| include: false
options(
  warn = 1,
  dplyr.summarise.inform = FALSE,
  htmltools.dir.version = FALSE
)
```

## Summary

This report presents an initial exploration of dengue surveillance data in relation to temperature and other environmental and contextual variables, with the aim of characterizing data quality, temporal dynamics, and plausible associations prior to formal analytical modeling.

## Data preparation

Cleaned datasets stored in RDS format were programmatically identified, imported, and consolidated into a unified in-memory structure to ensure reproducibility, scalability, and consistency across data sources.

```{r}
#| warning: false
#| echo: true
#| code-fold: true
library(tidyverse)
library(stringr)
library(readr)
library(purrr)
library(gt)
library(patchwork)
library(plotly)
library(DT)
library(sf)
library(dplyr)
library(ggplot2)
library(cowplot)
library(grid)
library(crosstalk)
library(scales)
library(ISOweek)

landing_dir <- file.path("data", "landing")
rds_files <- list.files(
  landing_dir,
  pattern = "\\.rds$",
  recursive = TRUE,
  full.names = TRUE
)

landing_data <- setNames(
  map(rds_files, readRDS),
  basename(rds_files) |> sub("\\.rds$", "", x = _)
)
```

## Data availability

### Datasets

This table summarizes the heterogeneous data sources integrated for the exploratory analyses

| Database | Administration level | Temporal unit | Variables |
|-----------------|-----------------|-----------------|---------------------|
| DGW_L2 | L2 | Epi week | Dengue cases (by age and sex) |
| PRCEWL2 | L2 | Epi week | Precipitation (mean, maximum, etc.) |
| TMPEWL2 | L2 | Epi week | Temperature (mean, maximum, etc.) |
| BEC_L2 | L2 | Years | Urban and population metrics |
| PRJ | L1AD | Years | Projected population |
| SECGDPGPC | L1AD | Years | GDP per capita (PPP, constant 2011 international USD) |
| IADB_Indicators_L2 | L2 | Years | Socioeconomic development indicators |
| SEC_Census_L2 | L2 | Years | Household and labor force indicators |
| SEC_GINI_L2 | L2 | Years | GINI index |

### Dengue cases

**Dengue case datasets** are available for several countries, including **Brazil (BR), Colombia (CO), Argentina (AR), Peru (PE), Panama (PA), Guatemala (GT), and Mexico (MX)**. Among these, BR, CO, PA, and PE present more than 10 consecutive years of dengue surveillance data

Years marked with an asterisk (\*) indicate the availability of both temperature and precipitation data at the L2 spatial level, defining the temporal window where joint dengue--climate analyses are feasible.

```{r}
#| echo: true
#| warning: false
#| message: false
#| code-fold: true
#| code-summary: "Show code"
#| out-width: "100%"
#| fig-align: "center"

DGW <- landing_data[["DGW_L2"]]
PRC <- landing_data[["PRCEWL2"]]
TMP <- landing_data[["TMPEWL2"]]

CONF_COL     <- "DGWCONFIRML2"          
CONF_SUS_COL <- "DGWCONFPROBL2"   

countries_env <- union(unique(PRC$ISO2), unique(TMP$ISO2))

prc_rng <- PRC %>%
  group_by(ISO2) %>%
  summarise(prc_min = min(EPIYEAR, na.rm = TRUE),
            prc_max = max(EPIYEAR, na.rm = TRUE), .groups = "drop")

tmp_rng <- TMP %>%
  group_by(ISO2) %>%
  summarise(tmp_min = min(EPIYEAR, na.rm = TRUE),
            tmp_max = max(EPIYEAR, na.rm = TRUE), .groups = "drop")

env_rng <- full_join(prc_rng, tmp_rng, by = "ISO2") %>%
  mutate(
    env_min = pmax(prc_min, tmp_min, na.rm = TRUE),
    env_max = pmin(prc_max, tmp_max, na.rm = TRUE),
    has_both = !is.na(prc_min) & !is.na(tmp_min)
  )

dengue_year <- DGW %>%
  filter(ISO2 %in% countries_env) %>%
  group_by(ISO2, year = DGWSYMEPIYR) %>%
  summarise(
    confirmed = sum(.data[[CONF_COL]], na.rm = TRUE),
    conf_plus_presum = sum(.data[[CONF_SUS_COL]], na.rm = TRUE),
    .groups = "drop"
  )

years_all <- sort(unique(dengue_year$year))
grid <- expand_grid(
  ISO2 = sort(unique(countries_env)),
  year = years_all
) %>%
  left_join(env_rng %>% select(ISO2, env_min, env_max, has_both), by = "ISO2") %>%
  mutate(
    star = ifelse(has_both & year >= env_min & year <= env_max, "*", "")
  )

plot_df <- grid %>%
  left_join(dengue_year, by = c("ISO2", "year")) %>%
  mutate(
    confirmed = replace_na(confirmed, 0),
    conf_plus_presum = replace_na(conf_plus_presum, 0),
    case_type = case_when(
      conf_plus_presum > 0 ~ "Confirmed + presumptive",
      confirmed > 0        ~ "Confirmed only",
      TRUE                 ~ "No cases"
    ),
    case_type = factor(case_type, levels = c("No cases", "Confirmed only", "Confirmed + presumptive"))
  )

p <- ggplot(plot_df, aes(x = year, y = ISO2, fill = case_type)) +
  geom_tile(color = "white", linewidth = 0.2) +
  geom_text(
    aes(label = star, color = case_type),
    size = 5,
    fontface = "bold"
  ) +
  geom_vline(xintercept = 2013.5, color = "red", linewidth = 0.8) +

  scale_fill_manual(
    values = c(
      "No cases" = "white",
      "Confirmed only" = "#2F4F4F",
      "Confirmed + presumptive" = "#003B73"
    ),
    breaks = c("Confirmed only", "Confirmed + presumptive"),
    guide = guide_legend(override.aes = list(alpha = 1))
  ) +

  scale_color_manual(
    values = c(
      "No cases" = "grey60",
      "Confirmed only" = "white",
      "Confirmed + presumptive" = "white"
    ),
    guide = "none"
  ) +

  scale_x_continuous(
    limits = c(1999, 2025),
    breaks = 2000:2024,
    expand = c(0, 0)
  ) +

  labs(x = "", y = "", fill = "") +

  theme_minimal(base_size = 11) +
  theme(
    panel.grid = element_blank(),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    legend.position = "top",
    legend.direction = "horizontal"
  ) +

  guides(
    fill = guide_legend(nrow = 1, byrow = TRUE)
  )

ggplotly(p)
```

Next figure shows the proportional distribution of dengue case records by country across four time periods (2000–2005, 2006–2011, 2012–2017, and 2018–2024). Marked heterogeneity in temporal coverage is evident across countries. **BR, CO, GT, and PE** display dengue data spanning multiple periods, whereas **AR and MX** concentrate their records in more recent years.

```{r}
#| echo: true
#| warning: false
#| message: false
#| code-fold: true
#| code-summary: "Show code"
#| out-width: "100%"
#| fig-align: "center"

dengue_year2 <- dengue_year %>%
  mutate(
    period = case_when(
      year >= 2000 & year <= 2005 ~ "2000-2005",
      year >= 2006 & year <= 2011 ~ "2006-2011",
      year >= 2012 & year <= 2017 ~ "2012-2017",
      year >= 2018 & year <= 2024 ~ "2018-2024",
      TRUE ~ NA_character_
    )
  )

dengue_period_pct <- dengue_year2 %>%
  group_by(ISO2, period) %>%
  summarise(cases = sum(confirmed, na.rm = TRUE), .groups = "drop") %>%
  group_by(ISO2) %>%
  mutate(pct = cases / sum(cases) * 100) %>%
  ungroup() %>%
  mutate(period = factor(period, levels = c("2000-2005","2006-2011","2012-2017","2018-2024")))

blue_palette <- c(
  "2000-2005" = "#001B3A",
  "2006-2011" = "#003B73",
  "2012-2017" = "#4C78A8",
  "2018-2024" = "#9ECAE1"
)

p2 <- ggplot(dengue_period_pct, aes(x = ISO2, y = pct, fill = period,
                                    text = paste0("ISO2: ", ISO2,
                                                  "<br>Period: ", period,
                                                  "<br>%: ", round(pct,1),
                                                  "<br>Cases: ", scales::comma(cases)))) +
  geom_col(width = 0.85, color = "white", linewidth = 0.2) +
  scale_fill_manual(values = blue_palette) +
  scale_y_continuous(labels = function(x) paste0(x, "%"), expand = c(0, 0)) +
  labs(x = "", y = "", fill = "") +
  theme_minimal(base_size = 11) +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "top",
    legend.direction = "horizontal"
  )

ggplotly(p2, tooltip = "text")
```

This interactive **line chart** displays the **total number of confirmed dengue cases per country** across **all available years**. Each line represents a country.

Because case counts may vary substantially between countries, the chart includes an optional **scaling control** that adjusts the **y-axis**

```{r}
#| echo: true
#| warning: false
#| message: false
#| code-fold: true

# Country-year
dgw_country_year <- DGW %>%
  transmute(
    ISO2 = ISO2,
    year = as.integer(DGWSYMEPIYR),
    cases = .data[[CONF_COL]]
  ) %>%
  filter(!is.na(ISO2), !is.na(year)) %>%
  group_by(ISO2, year) %>%
  summarise(cases = sum(cases, na.rm = TRUE), .groups = "drop")

# SALID1-year
stopifnot("SALID1" %in% names(DGW))

dgw_salid1_year <- DGW %>%
  transmute(
    ISO2 = ISO2,
    SALID1 = SALID1,
    year = as.integer(DGWSYMEPIYR),
    cases = .data[[CONF_COL]]
  ) %>%
  filter(!is.na(ISO2), !is.na(SALID1), !is.na(year)) %>%
  group_by(ISO2, SALID1, year) %>%
  summarise(cases = sum(cases, na.rm = TRUE), .groups = "drop")
```

```{r}
#| echo: false
#| warning: false
#| message: false
#| out-width: "100%"

TOP_N <- 20

df_overview <- dgw_country_year %>%
  group_by(ISO2) %>%
  mutate(total = sum(cases, na.rm = TRUE)) %>%
  ungroup() %>%
  arrange(desc(total)) %>%
  filter(ISO2 %in% unique(ISO2)[1:TOP_N]) %>%  # alternativa rápida, abajo va mejor
  select(-total)

# Mejor selección Top N
top_countries <- dgw_country_year %>%
  group_by(ISO2) %>%
  summarise(total = sum(cases, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(total)) %>%
  slice_head(n = TOP_N) %>%
  pull(ISO2)

df_overview <- dgw_country_year %>%
  filter(ISO2 %in% top_countries) %>%
  mutate(cases_sqrt = sqrt(pmax(cases, 0)))

p1 <- ggplot(
  df_overview,
  aes(
    x = year, y = cases,
    color = ISO2, group = ISO2,
    text = paste0("ISO2: ", ISO2, "<br>Year: ", year, "<br>Cases: ", scales::comma(cases))
  )
) +
  geom_line(alpha = 0.8, linewidth = 0.7) +
  theme_minimal() +
  labs(
    title = NULL,
    x = "Year", y = "Cases", color = "ISO2"
  )

g1 <- ggplotly(p1, tooltip = "text")

# Build y arrays for toggling
y_raw <- split(df_overview$cases, df_overview$ISO2)
y_sqrt <- split(df_overview$cases_sqrt, df_overview$ISO2)
trace_order <- sapply(g1$x$data, function(tr) tr$name)

y_raw_list  <- unname(lapply(trace_order, function(nm) y_raw[[nm]]))
y_sqrt_list <- unname(lapply(trace_order, function(nm) y_sqrt[[nm]]))

g1 %>%
  layout(
    yaxis = list(title = "Cases"),
    legend = list(itemclick = "toggleothers", itemdoubleclick = "toggle"),
    updatemenus = list(
      list(
        type = "buttons",
        direction = "right",
        x = 0.45, y = 1.15,
        buttons = list(
          list(
            method = "update",
            args = list(
              list(y = y_raw_list),
              list(yaxis = list(title = "Cases"),
                   title = NULL)
            ),
            label = "Raw"
          ),
          list(
            method = "update",
            args = list(
              list(y = y_sqrt_list),
              list(yaxis = list(title = "sqrt(Cases)"),
                   title = NULL)
            ),
            label = "Sqrt scale"
          )
        )
      )
    ),
    margin = list(t = 90)
  )


```

The following interactive line chart displays annual confirmed dengue cases across the **top 15 SALID1** urban areas for each selected country. Labels correspond to city names (L1NAME) Users can **switch countries** via a dropdown menu and toggle between linear and square-root scaling to better visualize differences in magnitude across cities.

```{r}
#| echo: false
#| warning: false
#| message: false
#| out-width: "100%"

wrap_words_br <- function(x, n = 3) {
  if (is.na(x) || !nzchar(x)) return(x)
  words <- unlist(str_split(x, "\\s+"))
  if (length(words) <= n) return(x)

  idx <- seq(n + 1, length(words), by = n)
  words[idx] <- paste0("<br>", words[idx])
  paste(words, collapse = " ")
}

l1ad <- st_read(
  "MS242_L1.gdb",
  layer = "SALURBAL_L1AD_NoSmallIslands_PublicIDs20230922",
  quiet = TRUE
)
SALID1_PUBSALID1 <- read_csv("SALID1_PUBSALID1.csv")

l1ad <- l1ad %>%
  left_join(
    SALID1_PUBSALID1,
    by = "PUBSALID1"
  )

l1_lookup <- l1ad %>%
  st_drop_geometry() %>%
  filter(!is.na(SALID1), !is.na(L1NAME)) %>%
  distinct(SALID1, L1NAME) %>%
  group_by(SALID1) %>%
  summarise(L1NAME = first(L1NAME), .groups = "drop")


TOP_SALID1 <- 15

salid1_rank <- dgw_salid1_year %>%
  group_by(ISO2, SALID1) %>%
  summarise(total = sum(cases, na.rm = TRUE), .groups = "drop") %>%
  left_join(l1_lookup, by = "SALID1") %>%
  mutate(
    L1LABEL = coalesce(L1NAME, as.character(SALID1)),
    L1LABEL_WRAPPED = vapply(L1LABEL, wrap_words_br, character(1), n = 3)
  ) %>%
  arrange(ISO2, desc(total)) %>%
  group_by(ISO2) %>%
  slice_head(n = TOP_SALID1) %>%
  ungroup()

isos <- sort(unique(salid1_rank$ISO2))

fig <- plot_ly()

y_linear_list <- list()
y_sqrt_list   <- list()

for (iso in isos) {

  salids_df <- salid1_rank %>%
    filter(ISO2 == iso) %>%
    select(SALID1, L1LABEL, L1LABEL_WRAPPED)
  if (nrow(salids_df) < TOP_SALID1) {
    salids_df <- bind_rows(
      salids_df,
      tibble(
        SALID1 = rep(NA_integer_, TOP_SALID1 - nrow(salids_df)),
        L1LABEL = rep(NA_character_, TOP_SALID1 - nrow(salids_df)),
        L1LABEL_WRAPPED = rep(NA_character_, TOP_SALID1 - nrow(salids_df))
      )
    )
  }

  for (k in seq_len(TOP_SALID1)) {

    s1   <- salids_df$SALID1[k]
    lab  <- salids_df$L1LABEL[k]
    labw <- salids_df$L1LABEL_WRAPPED[k]

    df <- dgw_salid1_year %>%
      filter(ISO2 == iso, SALID1 == s1) %>%
      arrange(year)

    if (is.na(s1) || nrow(df) == 0) {
      fig <- fig %>% add_trace(
        x = numeric(0),
        y = numeric(0),
        customdata = numeric(0),
        type = "scatter",
        mode = "lines",
        name = "NA",
        visible = FALSE,
        hoverinfo = "skip"
      )

      y_linear_list[[length(y_linear_list) + 1]] <- numeric(0)
      y_sqrt_list[[length(y_sqrt_list) + 1]]     <- numeric(0)

    } else {
      df <- df %>%
        mutate(
          cases_clean = if_else(is.na(cases), 0, cases),
          cases_sqrt  = sqrt(pmax(cases_clean, 0))
        )

      fig <- fig %>% add_trace(
        data = df,
        x = ~year,
        y = ~cases_clean,                 
        customdata = ~cases_clean,        
        type = "scatter",
        mode = "lines",
        name = as.character(labw),        
        visible = FALSE,
        hovertemplate = paste0(
          "ISO2: ", iso,
          "<br>L1NAME: ", labw,
          "<br>SALID1: ", s1,
          "<br>Year: %{x}",
          "<br>Cases: %{customdata:,}",
          "<extra></extra>"
        )
      )

      y_linear_list[[length(y_linear_list) + 1]] <- df$cases_clean
      y_sqrt_list[[length(y_sqrt_list) + 1]]     <- df$cases_sqrt
    }
  }
}


default_iso <- isos[1]
default_block <- which(isos == default_iso)

vis0 <- rep(FALSE, length(isos) * TOP_SALID1)
start0 <- (default_block - 1) * TOP_SALID1 + 1
end0   <- start0 + TOP_SALID1 - 1
vis0[start0:end0] <- TRUE

fig <- fig %>% style(visible = vis0)


country_buttons <- lapply(seq_along(isos), function(i) {

  vis <- rep(FALSE, length(isos) * TOP_SALID1)
  s <- (i - 1) * TOP_SALID1 + 1
  e <- s + TOP_SALID1 - 1
  vis[s:e] <- TRUE

  list(
    method = "update",
    args = list(
      list(visible = vis),
      list(title = NULL)
    ),
    label = isos[i]
  )
})


scale_buttons <- list(
  list(
    method = "update",
    args = list(
      list(y = y_linear_list),
      list(yaxis = list(title = "Cases"), annotations = NULL)
    ),
    label = "Linear"
  ),
  list(
    method = "update",
    args = list(
      list(y = y_sqrt_list),
      list(yaxis = list(title = "Sqrt(Cases)"), annotations = NULL)
    ),
    label = "Sqrt scale"
  )
)

fig %>%
  layout(
    title = NULL,
    xaxis = list(title = "Year"),
    yaxis = list(title = "Cases"),
    updatemenus = list(
      list(type = "dropdown", buttons = country_buttons, x = 0, y = 1.15),
      list(type = "buttons", direction = "right", buttons = scale_buttons, x = 0.55, y = 1.15)
    ),
    legend = list(orientation = "v")
  )
```

### Urban Form and Population Metrics (BEC)

The following table reports country level means of selected BEC indicators computed at the SALID2 unit. These descriptive contrasts suggest substantial cross-country heterogeneity in urban form and emissions proxies. For example, PE and AR show higher average street density, while PA and AR present higher per-capita CO2 emissions.

```{r}
#| echo: true
#| warning: false
#| message: false
#| code-fold: true
#| out-width: "100%"

BEC_dataset <- read_csv("data/other data files/BEC_L2_08162023.csv", show_col_types = FALSE)
id_cols <- c("ISO2", "SALID0", "SALID1", "SALID2")

BEC_long <- BEC_dataset %>%
  pivot_longer(
    cols = -all_of(id_cols),
    names_to = "full_name",
    values_to = "value"
  )

vars_keep <- c(
  "BECNBHDCENTL2",
  "BECTUAREAL2",
  "BECPCTURBANL2",
  "BECTGSAREAL2",
  "BECADSTTDENSL2",
  "BECTOTCO2L2",
  "BECPERCAPCO2L2"
)

var_labels <- c(
  BECNBHDCENTL2   = "Distance to neighborhood center",
  BECTUAREAL2    = "Total urban area",
  BECPCTURBANL2  = "Percent urban area",
  BECTGSAREAL2   = "Total green space area",
  BECADSTTDENSL2 = "Street density",
  BECTOTCO2L2    = "Total CO2 emissions",
  BECPERCAPCO2L2 = "Per capita CO2 emissions"
)

bec_country_mean <- BEC_long %>%
  filter(full_name %in% vars_keep) %>%
  group_by(ISO2, full_name) %>%
  summarise(mean_value = mean(value, na.rm = TRUE), .groups = "drop") %>%
  mutate(variable_label = unname(var_labels[full_name])) %>%
  select(ISO2, variable_label, mean_value)

bec_country_wide <- bec_country_mean %>%
  pivot_wider(names_from = variable_label, values_from = mean_value) %>%
  arrange(ISO2) %>%
  mutate(across(where(is.numeric), ~ round(.x, 2)))   
bec_unique_counts <- BEC_dataset %>%
  group_by(ISO2) %>%
  summarise(
    Cities = n_distinct(SALID1, na.rm = TRUE),
    Districs = n_distinct(SALID2, na.rm = TRUE),
    .groups = "drop"
  )

bec_country_final <- bec_unique_counts %>%
  left_join(bec_country_wide, by = "ISO2") %>%
  arrange(ISO2)

datatable(
  bec_country_final,
  rownames = FALSE,
  options = list(pageLength = 10, scrollX = TRUE)
)

```

## Exploratory visualization 

### Heatmaps

Bars represent the mean weekly dengue incidence aggregated across years for a given country, while the heatmap summarizes weekly environmental conditions (temperature or precipitation) by year. This combined view facilitates the identification of recurrent seasonal patterns, anomalous years, and potential temporal coincidence between dengue activity and environmental variability. No causal inference is implied.

```{r}
#| echo: false
#| warning: false
#| message: false

library(htmltools)
library(plotly)
library(DT)
library(tidyverse)

library(htmltools)
library(plotly)
library(DT)
library(tidyverse)

CONF_COL <- "DGWCONFIRML2"

period_def <- function(year) {
  dplyr::case_when(
    year >= 2000 & year <= 2005 ~ "2000-2005",
    year >= 2006 & year <= 2011 ~ "2006-2011",
    year >= 2012 & year <= 2017 ~ "2012-2017",
    year >= 2018 & year <= 2024 ~ "2018-2024",
    TRUE ~ NA_character_
  )
}

# 1) Dengue weekly aggregates (barras)
DGW_yearweek_sum <- DGW %>%
  transmute(
    ISO2,
    EPIYEAR = as.integer(DGWSYMEPIYR),
    EPIWEEK = as.integer(DGWSYMEPIWK),
    confirmed = as.numeric(.data[[CONF_COL]])
  ) %>%
  filter(!is.na(ISO2), !is.na(EPIYEAR), !is.na(EPIWEEK), EPIWEEK >= 1, EPIWEEK <= 53) %>%
  group_by(ISO2, EPIYEAR, EPIWEEK) %>%
  summarise(confirmed_sum = sum(confirmed, na.rm = TRUE), .groups = "drop") %>%
  tidyr::complete(ISO2, EPIYEAR, EPIWEEK = 1:53, fill = list(confirmed_sum = 0))

DGW_week_mean <- DGW_yearweek_sum %>%
  group_by(ISO2, EPIWEEK) %>%
  summarise(confirmed_week_mean = mean(confirmed_sum, na.rm = TRUE), .groups = "drop") %>%
  tidyr::complete(ISO2, EPIWEEK = 1:53, fill = list(confirmed_week_mean = 0))

# 2) Climate weekly aggregates (heatmaps)
TMP_agg <- TMP %>%
  transmute(
    ISO2,
    EPIYEAR = as.integer(EPIYEAR),
    EPIWEEK = as.integer(EPIWEEK),
    TMP_mean = as.numeric(TMPEWMEAN_L2)
  ) %>%
  filter(!is.na(ISO2), !is.na(EPIYEAR), !is.na(EPIWEEK), EPIWEEK >= 1, EPIWEEK <= 53) %>%
  group_by(ISO2, EPIYEAR, EPIWEEK) %>%
  summarise(TMP_mean = mean(TMP_mean, na.rm = TRUE), .groups = "drop") %>%
  tidyr::complete(ISO2, EPIYEAR, EPIWEEK = 1:53)

PRC_agg <- PRC %>%
  transmute(
    ISO2,
    EPIYEAR = as.integer(EPIYEAR),
    EPIWEEK = as.integer(EPIWEEK),
    PRC_mean = as.numeric(PRCEWMEANL2)
  ) %>%
  filter(!is.na(ISO2), !is.na(EPIYEAR), !is.na(EPIWEEK), EPIWEEK >= 1, EPIWEEK <= 53) %>%
  group_by(ISO2, EPIYEAR, EPIWEEK) %>%
  summarise(PRC_mean = mean(PRC_mean, na.rm = TRUE), .groups = "drop") %>%
  tidyr::complete(ISO2, EPIYEAR, EPIWEEK = 1:53)

# 3) Countries overlap
countries <- sort(intersect(
  unique(DGW_week_mean$ISO2),
  union(unique(TMP_agg$ISO2), unique(PRC_agg$ISO2))
))
stopifnot(length(countries) > 0)

# 4) Paletas (mantener “blue” y “warm” como pediste)
# Plotly colorscale: list(list(pos, color), ...)
colorscale_warm <- list(
  list(0.0, "#2c7fb8"),
  list(0.5, "#ffffbf"),
  list(1.0, "#d73027")
)

colorscale_blue <- list(
  list(0.0, "#deebf7"),
  list(1.0, "#08519c")
)

# 5) Heatmap plotly con leyenda abajo
make_heatmap_plotly <- function(df, iso, value_col, title_prefix, zlab, colorscale_use) {

  dfi <- df %>%
    filter(ISO2 == iso) %>%
    mutate(EPIYEAR = as.integer(EPIYEAR), EPIWEEK = as.integer(EPIWEEK)) %>%
    filter(EPIWEEK >= 1, EPIWEEK <= 53)

  yrs <- sort(unique(dfi$EPIYEAR))
  wks <- 1:53

  mat <- dfi %>%
    select(EPIYEAR, EPIWEEK, val = all_of(value_col)) %>%
    complete(EPIYEAR = yrs, EPIWEEK = wks) %>%
    arrange(EPIYEAR, EPIWEEK) %>%
    pivot_wider(names_from = EPIWEEK, values_from = val) %>%
    select(-EPIYEAR) %>%
    as.matrix()

  plot_ly(
    x = wks, y = yrs, z = mat,
    type = "heatmap",
    colorscale = colorscale_use,
    colorbar = list(
      orientation = "h",
      x = 0.5, xanchor = "center",
      y = -0.25,
      thickness = 12
    ),
    hovertemplate = paste0(
      "ISO2: ", iso,
      "<br>Year: %{y}",
      "<br>Week: %{x}",
      "<br>", zlab, ": %{z:.2f}",
      "<extra></extra>"
    )
  ) %>%
    layout(
      title = paste0(title_prefix, " - ", iso),
      xaxis = list(title = "Epi week", range = c(1, 53)),
      yaxis = list(title = "Year")
    )
}

# 6) Barras plotly (escala LINEAL)
make_bars_plotly <- function(iso) {
  wks <- 1:53  # <- FIX: define aquí para que NO dependa de nada externo

  df <- DGW_week_mean %>%
    filter(ISO2 == iso) %>%
    arrange(EPIWEEK) %>%
    mutate(
      EPIWEEK = as.integer(EPIWEEK),
      confirmed_week_mean = as.numeric(confirmed_week_mean)
    ) %>%
    tidyr::complete(EPIWEEK = wks, fill = list(confirmed_week_mean = 0))

  plot_ly(
    data = df,
    x = ~EPIWEEK,
    y = ~confirmed_week_mean,
    type = "bar",
    hovertemplate = paste0(
      "ISO2: ", iso,
      "<br>Week: %{x}",
      "<br>Mean cases: %{y:.2f}",
      "<extra></extra>"
    )
  ) %>%
    layout(
      title = paste0("Mean weekly dengue - ", iso),
      xaxis = list(title = "Epi week", range = c(1, 53)),
      yaxis = list(title = "Mean weekly cases")
    )
}

# 7) Tabla resumen por periodos (DT)
make_period_table <- function(df, iso, value_col, label_value, table_id) {

  tab <- df %>%
    filter(ISO2 == iso) %>%
    mutate(period = period_def(EPIYEAR)) %>%
    filter(!is.na(period)) %>%
    group_by(period) %>%
    summarise(
      mean = mean(.data[[value_col]], na.rm = TRUE),
      sd   = sd(.data[[value_col]], na.rm = TRUE),
      min  = min(.data[[value_col]], na.rm = TRUE),
      max  = max(.data[[value_col]], na.rm = TRUE),
      .groups = "drop"
    ) %>%
    arrange(factor(period, levels = c("2000-2005","2006-2011","2012-2017","2018-2024"))) %>%
    select(period, mean, sd, min, max)

  if (nrow(tab) == 0) {
    return(tags$p(style="color:#666;", paste0("No data for ", iso, " in defined periods.")))
  }

  DT::datatable(
    tab,
    rownames = FALSE,
    elementId = table_id,
    options = list(
      pageLength = 10,
      scrollX = TRUE,
      autoWidth = TRUE
    ),
    caption = htmltools::tags$caption(
      style = "caption-side: top; text-align: left; font-weight: 600;",
      paste0("Summary by period - ", iso)
    )
  ) %>% DT::formatRound(columns = c("mean","sd","min","max"), digits = 2)
}

# 8) Pre-render widgets por país
widgets_by_iso <- lapply(countries, function(iso) {
  list(
    bars = make_bars_plotly(iso),

    tmp_hm  = make_heatmap_plotly(TMP_agg, iso, "TMP_mean",
                                  "Temperature heatmap", "Temp (C)",
                                  colorscale_use = colorscale_warm),
    tmp_tab = make_period_table(TMP_agg, iso, "TMP_mean",
                                "Temperature (weekly mean)",
                                table_id = paste0("dt_tmp_", iso)),

    prc_hm  = make_heatmap_plotly(PRC_agg, iso, "PRC_mean",
                                  "Precipitation heatmap", "Prc (mm)",
                                  colorscale_use = colorscale_blue),
    prc_tab = make_period_table(PRC_agg, iso, "PRC_mean",
                                "Precipitation (weekly mean)",
                                table_id = paste0("dt_prc_", iso))
  )
})
names(widgets_by_iso) <- countries


```

```{r}
#| echo: false
#| warning: false
#| message: false

iso0 <- countries[1]

dropdown <- tags$div(
  tags$label(`for` = "iso_select", tags$b("Select country (ISO2):")),
  tags$select(
    id = "iso_select",
    style = "margin-left:8px; padding:4px 6px;",
    lapply(countries, function(iso) {
      tags$option(value = iso, if (iso == iso0) "selected" else NULL, iso)
    })
  ),
  tags$hr(style = "margin: 12px 0;")
)

panels <- tagList(
  lapply(countries, function(iso) {
    is_default <- iso == iso0

    tags$div(
      class = "iso-panel",
      id = paste0("panel_", iso),
      style = if (is_default) {
        "display:block; position:static; left:auto; top:auto; width:100%;"
      } else {
        "display:block; position:absolute; left:-10000px; top:0; width:100%;"
      },

      tags$h4("Bars"),
      widgets_by_iso[[iso]]$bars,

      tags$h4("Temperature"),
      widgets_by_iso[[iso]]$tmp_hm,
      widgets_by_iso[[iso]]$tmp_tab,

      tags$h4("Precipitation"),
      widgets_by_iso[[iso]]$prc_hm,
      widgets_by_iso[[iso]]$prc_tab
    )
  })
)

js <- tags$script(HTML("
(function(){
  function hideAll(){
    var panels = document.querySelectorAll('.iso-panel');
    panels.forEach(function(p){
      p.style.display = 'block';
      p.style.position = 'absolute';
      p.style.left = '-10000px';
      p.style.top = '0px';
      p.style.width = '100%';
    });
  }

  function showPanel(iso){
    hideAll();

    var el = document.getElementById('panel_' + iso);
    if(!el) return;

    el.style.display = 'block';
    el.style.position = 'static';
    el.style.left = 'auto';
    el.style.top = 'auto';
    el.style.width = '100%';

    // Plotly resize
    if(window.Plotly){
      var plots = el.querySelectorAll('.plotly.html-widget');
      plots.forEach(function(node){
        try { Plotly.Plots.resize(node); } catch(e) {}
      });
    }

    // DataTables adjust
    setTimeout(function(){
      if(window.jQuery && jQuery.fn && jQuery.fn.dataTable){
        jQuery(el).find('table.dataTable').each(function(){
          try {
            var dt = jQuery(this).DataTable();
            dt.columns.adjust();
            dt.draw(false);
          } catch(e) {}
        });
      }
    }, 150);
  }

  var sel = document.getElementById('iso_select');
  if(sel){
    sel.addEventListener('change', function(){ showPanel(this.value); });
  }
})();
"))


browsable(tagList(dropdown, panels, js))
```

### Maps

![](img/Captura%20de%20pantalla%202026-02-03%20073554.png)

![](img/Captura%20de%20pantalla%202026-02-03%20073608.png)


```{r}
#| echo: false
#| warning: false
#| message: false

to_week_start <- function(year, week) {
  x <- sprintf("%d-W%02d-1", as.integer(year), as.integer(week))
  suppressWarnings(as.Date(ISOweek2date(x)))
}

max_lag <- 5
lag_vals <- 0:max_lag
n_bins <- 35


DGW_s1 <- DGW %>%
  transmute(
    ISO2,
    SALID1 = as.integer(SALID1),
    year   = as.integer(DGWSYMEPIYR),
    week   = as.integer(DGWSYMEPIWK),
    cases  = as.numeric(.data[[CONF_COL]])
  ) %>%
  filter(!is.na(ISO2), !is.na(SALID1), week >= 1, week <= 53) %>%
  group_by(ISO2, SALID1, year, week) %>%
  summarise(cases = sum(cases, na.rm = TRUE), .groups = "drop") %>%
  mutate(week_start = to_week_start(year, week)) %>%
  filter(!is.na(week_start))

# -----------------------------
# Weekly temperature by SALID1
# -----------------------------
TMP_s1 <- TMP %>%
  transmute(
    ISO2,
    SALID1 = as.integer(SALID1),
    year   = as.integer(EPIYEAR),
    week   = as.integer(EPIWEEK),
    temp   = as.numeric(TMPEWMEAN_L2)
  ) %>%
  filter(!is.na(ISO2), !is.na(SALID1), week >= 1, week <= 53) %>%
  group_by(ISO2, SALID1, year, week) %>%
  summarise(temp = mean(temp, na.rm = TRUE), .groups = "drop") %>%
  mutate(week_start = to_week_start(year, week)) %>%
  filter(!is.na(week_start))


prc_candidates <- names(PRC)[
  str_detect(names(PRC), regex("PRC", ignore_case = TRUE)) &
    str_detect(names(PRC), regex("MEAN|EWMEAN|AVG", ignore_case = TRUE))
]

if (length(prc_candidates) == 0) {
  stop("No precipitation mean column found in PRC. Run names(PRC) to inspect available columns.")
}

PRC_COL <- prc_candidates[1]
message("Using precipitation column: ", PRC_COL)

PRC_s1 <- PRC %>%
  transmute(
    ISO2,
    SALID1 = as.integer(SALID1),
    year   = as.integer(EPIYEAR),
    week   = as.integer(EPIWEEK),
    prc    = as.numeric(.data[[PRC_COL]])
  ) %>%
  filter(!is.na(ISO2), !is.na(SALID1), week >= 1, week <= 53) %>%
  group_by(ISO2, SALID1, year, week) %>%
  summarise(prc = mean(prc, na.rm = TRUE), .groups = "drop") %>%
  mutate(week_start = to_week_start(year, week)) %>%
  filter(!is.na(week_start))

CLIM_ALL <- TMP_s1 %>%
  left_join(PRC_s1, by = c("ISO2","SALID1","year","week","week_start")) %>%
  left_join(DGW_s1, by = c("ISO2","SALID1","year","week","week_start")) %>%
  mutate(cases = coalesce(cases, 0))

countries <- sort(unique(DGW_s1$ISO2))


build_heat_mean_annual_sum <- function(df, iso, varname, lag_vals, n_bins) {

  base <- df %>%
    filter(ISO2 == iso) %>%
    select(SALID1, year, week_start, cases, !!sym(varname)) %>%
    rename(clim = !!sym(varname)) %>%
    arrange(SALID1, week_start) %>%
    group_by(SALID1)

  for (k in lag_vals) {
    base <- base %>% mutate(!!paste0("cases_lag", k) := lead(cases, k))
  }
  base <- base %>% ungroup()

  df_long <- base %>%
    pivot_longer(
      cols = starts_with("cases_lag"),
      names_to = "lag",
      values_to = "cases_lag"
    ) %>%
    mutate(lag = as.integer(gsub("cases_lag", "", lag))) %>%
    filter(!is.na(clim), !is.na(cases_lag))

  clim_range <- range(df_long$clim, na.rm = TRUE)
  breaks <- seq(clim_range[1], clim_range[2], length.out = n_bins + 1)

  df_binned <- df_long %>%
    mutate(
      clim_bin = findInterval(clim, vec = breaks, all.inside = TRUE),
      clim_mid = (breaks[clim_bin] + breaks[clim_bin + 1]) / 2
    )

  annual_sum <- df_binned %>%
    group_by(year, lag, clim_mid) %>%
    summarise(annual_cases = sum(cases_lag, na.rm = TRUE), .groups = "drop")

  df_heat <- annual_sum %>%
    group_by(lag, clim_mid) %>%
    summarise(intensity = mean(annual_cases, na.rm = TRUE), .groups = "drop")

  grid <- tidyr::expand_grid(
    lag = lag_vals,
    clim_mid = sort(unique(df_heat$clim_mid))
  )

  grid %>%
    left_join(df_heat, by = c("lag","clim_mid")) %>%
    mutate(intensity = coalesce(intensity, 0))
}

legend_lab <- scales::label_number(
  accuracy = 1,
  big.mark = ",",
  scale_cut = scales::cut_short_scale()
)

for (iso in countries) {

  cat("\n\n")

 df_temp <- build_heat_mean_annual_sum(CLIM_ALL, iso, "temp", lag_vals, n_bins)


  p_temp <- ggplot(df_temp, aes(x = lag, y = clim_mid, fill = intensity)) +
    geom_tile() +
    scale_x_continuous(breaks = lag_vals) +
    scale_fill_gradient(
      low = "#fee5d9", high = "#a50f15",
      labels = legend_lab
    ) +
    labs(
      title = paste0(iso, " | Temperature(t) vs Lag, TOTAL cases at t+lag"),
      x = "Lag (weeks)",
      y = "Temperature (°C, bin midpoint)",
      fill = "Total dengue cases\n(t+lag)"
    ) +
    theme_bw() +
    theme(panel.grid = element_blank())

  print(p_temp)

  
}
```


